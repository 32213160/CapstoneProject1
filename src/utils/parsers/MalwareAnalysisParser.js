// src/utils/MalwareAnalysisParser.js

/**
* 악성코드 분석 응답을 파싱하는 유틸리티 함수들
*/

export const parseMalwareAnalysisResponse = (response) => {
  try {
    // 새로운 응답 형식: analysisResult 구조 확인
    let reportVT, reportLLM;
    
    if (response.analysisResult) {
      // 새로운 형식: analysisResult 안에 reportfromVT, reportfromLLM이 있는 경우
      reportVT = response.analysisResult?.reportfromVT || {};
      reportLLM = response.analysisResult?.reportfromLLM || {};
    } else {
      // 기존 형식: 직접 reportfromVT, reportfromLLM이 있는 경우
      reportVT = response?.reportfromVT || {};
      reportLLM = response?.reportfromLLM || {};
    }

    const vtData = reportVT?.data || {};
    const vtId = reportVT?._id || null;

    const llmReport = reportLLM?.report || null;
    const llmId = reportLLM?._id || null;

    // 추출된 ID (여러 위치에서 찾기)
    const extractedId = response?.extractedId || vtId || llmId;

    // VirusTotal 분석 통계
    const analysisStats = vtData?.attributes?.lastAnalysisStats || {};
    const analysisResults = vtData?.attributes?.lastAnalysisResults || {};

    // 악성 탐지 엔진 목록 추출
    const maliciousEngines = Object.entries(analysisResults)
      .filter(([engine, result]) => result.category === 'malicious')
      .map(([engine, result]) => ({
        engine,
        result: result.result
      }));

    return {
      success: true,
      sessionId: response.sessionId || null,
      fileName: response.fileName || 'Unknown File',
      extractedId,
      virusTotal: {
        id: vtId,
        scanId: vtData?.id_SHA256 || vtData?.id,
        stats: analysisStats,
        maliciousCount: analysisStats?.malicious || 0,
        totalEngines: Object.keys(analysisResults).length,
        maliciousEngines,
        detectionRate: analysisStats?.malicious
          ? `${analysisStats.malicious}/${Object.keys(analysisResults).length}`
          : '0/0'
      },
      llmAnalysis: {
        id: llmId,
        report: llmReport,
        summary: extractSummaryFromReport(llmReport)
      },
      rawResponse: response
    };
  } catch (error) {
    console.error('파싱 오류:', error);
    return {
      success: false,
      error: error.message,
      rawResponse: response
    };
  }
};

/**
* LLM 보고서에서 요약 정보 추출
*/
const extractSummaryFromReport = (report) => {
  if (!report) return null;

  try {
    // 악성 확률 추출
    const probabilityMatch = report.match(/악성일 확률은 (\d+\.?\d*)%/);
    const maliciousProbability = probabilityMatch ? parseFloat(probabilityMatch[1]) : null;

    // 권한 정보 추출
    const permissionMatches = report.match(/- `([^`]+)`/g);
    const permissions = permissionMatches
      ? permissionMatches.map(match => match.replace(/- `|`/g, ''))
      : [];

    // 위험도 평가
    const riskLevel = maliciousProbability
      ? maliciousProbability > 80 ? 'HIGH'
        : maliciousProbability > 50 ? 'MEDIUM'
        : 'LOW'
      : 'UNKNOWN';

    return {
      maliciousProbability,
      permissions,
      riskLevel,
      recommendedAction: riskLevel === 'HIGH' ? '즉시 삭제 권장' : '주의 깊게 검토 필요'
    };
  } catch (error) {
    console.error('요약 추출 오류:', error);
    return null;
  }
};

/**
* 분석 결과를 사용자 친화적인 메시지로 변환
*/
export const formatAnalysisMessage = (parsedData) => {
  if (!parsedData.success) {
    return '분석 결과를 처리하는 중 오류가 발생했습니다.';
  }

  const { virusTotal, llmAnalysis } = parsedData;

  const detectionInfo = virusTotal.maliciousCount > 0
    ? `${virusTotal.detectionRate} 백신 엔진에서 악성코드로 탐지`
    : '악성코드로 탐지되지 않음';

  const riskInfo = llmAnalysis.summary?.riskLevel
    ? `위험도: ${llmAnalysis.summary.riskLevel}`
    : '';

  return `분석 완료: ${detectionInfo}. ${riskInfo}`;
};
